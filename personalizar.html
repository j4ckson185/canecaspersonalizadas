<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caneca 3D Personalizada Premium</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            color: #343a40;
            overscroll-behavior-y: none;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            max-width: 1200px;
            margin: 0 auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            background-color: white;
            overflow-x: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #3a7bd5, #3a6073);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1rem;
            opacity: 0.9;
        }
        
        .preview-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
        }
        
        .preview-column {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
        }
        
        .preview-section {
            flex: 1;
            position: relative;
            height: 45vh;
            border-bottom: 1px solid #e9ecef;
            touch-action: auto;
            overflow: hidden;
        }
        
        .preview-section h3 {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 1rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        canvas {
            width: 100%;
            height: 100%;
            touch-action: auto;
            display: block;
            pointer-events: none;
        }
        
        .image-upload {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 12px;
            width: 80%;
            margin-left: auto;
            margin-right: auto;
            box-sizing: border-box;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #495057;
        }
        
        input[type="file"] {
            display: block;
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background-color: #ffffff;
            font-size: 0.9rem;
        }

        /* Novas estilizações para preço e frete */
        .pricing-shipping {
            background: #f8f9fa;
            padding: 20px;
            margin: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .price-options {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .price-option {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .shipping-calculator {
            margin-top: 20px;
        }

        .cep-input {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .cep-input input {
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            width: 200px;
        }

        .shipping-options {
            margin-top: 15px;
            display: none;
        }

        .shipping-option {
            background: white;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .shipping-option.selected {
            border: 2px solid #3a7bd5;
        }

        .price-preview {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.1);
            min-width: 250px;
            z-index: 1000;
        }

        .calculate-button {
            background: #3a7bd5;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .calculate-button:hover {
            background: #2d62aa;
        }
        
        footer {
            background: #343a40;
            color: white;
            text-align: center;
            padding: 15px;
            font-size: 0.9rem;
            margin-top: auto;
        }
        
        @media (max-width: 768px) {
            header {
                padding: 15px;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            .preview-section {
                height: 38vh;
            }
            
            .preview-container {
                flex-direction: column;
                padding: 10px;
            }
            
            .image-upload {
                padding: 10px;
            }
            
            input[type="file"] {
                font-size: 0.9rem;
                padding: 6px;
            }
            
            label {
                font-size: 0.9rem;
            }

            .price-preview {
                bottom: 0;
                right: 0;
                left: 0;
                border-radius: 8px 8px 0 0;
            }

            .price-options {
                flex-direction: column;
            }

            .cep-input {
                flex-direction: column;
            }

            .cep-input input {
                width: 100%;
            }
        }

                .shipping-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 5px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .shipping-option span {
            flex: 1;
        }

        .shipping-option .price {
            flex: 0 0 100px;
            text-align: right;
        }

        .shipping-option input[type="radio"] {
            margin-left: 10px;
        }

        .shipping-options {
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Personalizador de Canecas 3D</h1>
            <div class="subtitle">Crie sua caneca personalizada com suas próprias imagens</div>
        </header>
        
        <div class="preview-container">
            <div class="preview-column">
                <div class="image-upload">
                    <label for="frontImageInput">Imagem para o Lado Frontal:</label>
                    <input type="file" id="frontImageInput" accept="image/*">
                </div>
                <div class="preview-section">
                    <h3>Lado Frontal da Caneca</h3>
                    <canvas id="frontCanvas"></canvas>
                </div>
            </div>
            
            <div class="preview-column">
                <div class="image-upload">
                    <label for="backImageInput">Imagem para o Lado Traseiro:</label>
                    <input type="file" id="backImageInput" accept="image/*">
                </div>
                <div class="preview-section">
                    <h3>Lado Traseiro da Caneca</h3>
                    <canvas id="backCanvas"></canvas>
                </div>
            </div>

            <!-- Nova seção de preço e frete -->
            <div class="pricing-shipping">
                <h3>Opções de Personalização</h3>
                <div class="price-options">
                    <div class="price-option">
                        <input type="radio" id="oneSide" name="sides" checked>
                        <label for="oneSide">Um lado (R$ 30,00)</label>
                    </div>
                    <div class="price-option">
                        <input type="radio" id="twoSides" name="sides">
                        <label for="twoSides">Dois lados (R$ 35,00)</label>
                    </div>
                    <div class="price-option">
                        <input type="checkbox" id="giftBox">
                        <label for="giftBox">Adicionar caixinha (+ R$ 5,00)</label>
                    </div>
                </div>

                <div class="shipping-calculator">
                    <h3>Calcular Frete</h3>
                    <div class="cep-input">
                        <input type="text" id="cep" maxlength="8" placeholder="Digite seu CEP">
                        <button class="calculate-button" onclick="calcularFrete()">Calcular</button>
                    </div>
                    <div id="shipping-options" class="shipping-options">
                        <div class="shipping-option">
                            <span>PAC</span>
                            <span class="price">Calculando...</span>
                        </div>
                        <div class="shipping-option">
                            <span>SEDEX</span>
                            <span class="price">Calculando...</span>
                        </div>
                        <div class="shipping-option" id="motoboy-option" style="display: none;">
                            <span>Motoboy (Natal)</span>
                            <span class="price">Calculando...</span>
                        </div>
                        <div class="finish-order-section" style="display: none;">
    <button class="finish-button" onclick="finalizarPedido()">
        Finalizar Pedido
    </button>
</div>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            &copy; 2025 Personalizador de Canecas 3D - Todos os direitos reservados
        </footer>

        <!-- Preview do preço fixo -->
        <div class="price-preview">
            <h4>Resumo do Pedido</h4>
            <div id="price-breakdown"></div>
            <div id="total-price">Total: R$ 30,00</div>
        </div>
    </div>

    <script>
        // Variáveis globais
        let sceneFront, sceneBack, cameraFront, cameraBack, rendererFront, rendererBack;
        let mugFront, mugBack, tableGroup;
        let frontImageUrl = null;
        let backImageUrl = null;
        let baseUVs = null;
        let lightsFront = [];
        let lightsBack = [];
        
        // Texturas
        let woodTexture;
        
        // Verificar se é dispositivo móvel
        const isMobile = window.innerWidth <= 768;
        
        // Inicialização
        init();
        animate();
        
        // Função principal de inicialização
        function init() {
            // Configuração da cena frontal
            sceneFront = new THREE.Scene();
            sceneFront.background = new THREE.Color(0xf5f5f5);
            
            // Configuração da cena traseira
            sceneBack = new THREE.Scene();
            sceneBack.background = new THREE.Color(0xf5f5f5);
            
            // Carregar texturas
            const textureLoader = new THREE.TextureLoader();
            
            // Textura de madeira para a mesa
            woodTexture = textureLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/textures/hardwood2_diffuse.jpg');
            woodTexture.wrapS = THREE.RepeatWrapping;
            woodTexture.wrapT = THREE.RepeatWrapping;
            woodTexture.repeat.set(4, 4);
            
            // Configuração de câmeras
            const aspect = window.innerWidth / (window.innerHeight * 0.45);
            
            // Ajuste câmeras com base na plataforma
            if (isMobile) {
                cameraFront = new THREE.PerspectiveCamera(40, aspect, 0.1, 1000);
                cameraFront.position.set(0, 0, 10);  // Ajustado para celular
                
                cameraBack = new THREE.PerspectiveCamera(40, aspect, 0.1, 1000);
                cameraBack.position.set(0, 0, 10);
            } else {
                cameraFront = new THREE.PerspectiveCamera(40, aspect, 0.1, 1000);
                cameraFront.position.set(0, 0, 9.5);
                
                cameraBack = new THREE.PerspectiveCamera(40, aspect, 0.1, 1000);
                cameraBack.position.set(0, 0, 9.5);
            }
            
            // Configuração de renderizadores
            rendererFront = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('frontCanvas'), 
                antialias: true
            });
            
            rendererBack = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('backCanvas'), 
                antialias: true
            });
            
            const width = window.innerWidth;
            const height = window.innerHeight * 0.45;
            
            rendererFront.setSize(width, height);
            rendererBack.setSize(width, height);
            
            // Alta qualidade para melhor resolução
            rendererFront.setPixelRatio(window.devicePixelRatio);
            rendererBack.setPixelRatio(window.devicePixelRatio);
            
            // Ativar sombras
            rendererFront.shadowMap.enabled = true;
            rendererBack.shadowMap.enabled = true;
            rendererFront.shadowMap.type = THREE.PCFSoftShadowMap;
            rendererBack.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Configurar iluminação para ambas as cenas
            setupLighting(sceneFront, lightsFront);
            setupLighting(sceneBack, lightsBack);
            
            // Criar ambiente (mesa)
            tableGroup = createTable();
            sceneFront.add(tableGroup.clone());
            sceneBack.add(tableGroup.clone());
            
            // Criar canecas
            mugFront = createMug();
            mugBack = createMug();
            
            // Posicionar canecas
            mugFront.rotation.y = Math.PI; // Rotação para ver a frente
            mugBack.rotation.y = 0; // Rotação para ver a parte de trás
            
            sceneFront.add(mugFront);
            sceneBack.add(mugBack);
            
            // Configurar eventos de interação
            setupControls();
            
            // Adicionar eventos de redimensionamento
            window.addEventListener('resize', onWindowResize);
        }
        
        // Configurar iluminação
        function setupLighting(scene, lightsArray) {
            // Luz ambiente geral
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            lightsArray.push(ambientLight);
            
            // Luz direcional principal (sol)
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(10, 20, 15);
            mainLight.castShadow = true;
            
            // Configuração da área de sombra
            mainLight.shadow.camera.left = -10;
            mainLight.shadow.camera.right = 10;
            mainLight.shadow.camera.top = 10;
            mainLight.shadow.camera.bottom = -10;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            
            scene.add(mainLight);
            lightsArray.push(mainLight);
            
            // Luz de preenchimento para suavizar sombras
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-15, 10, 8);
            scene.add(fillLight);
            lightsArray.push(fillLight);
            
            // Luz de destaque para brilho nas bordas
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.2);
            rimLight.position.set(5, 5, -10);
            scene.add(rimLight);
            lightsArray.push(rimLight);
        }
        
        // Criar mesa
        function createTable() {
            const group = new THREE.Group();
            
            // Material da mesa de madeira
            const woodMaterial = new THREE.MeshStandardMaterial({
                map: woodTexture,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Tampo da mesa - tamanho reduzido
            const tableWidth = isMobile ? 15 : 20; // Mesa menor em dispositivos móveis
            
            const tableTop = new THREE.Mesh(
                new THREE.BoxGeometry(tableWidth, 1, tableWidth),
                woodMaterial
            );
            
            // Posição da mesa - mais próxima da caneca
            tableTop.position.y = -2.5;
            tableTop.receiveShadow = true;
            group.add(tableTop);
            
            return group;
        }
        
        // Criar caneca 3D
        function createMug() {
            const mug = new THREE.Group();
            
            // Ajustar tamanho da caneca com base no dispositivo
            let height, radius;
            
            if (isMobile) {
                height = 3.6;  // Ligeiramente maior para celular
                radius = 2.4;  // Mais larga
            } else {
                height = 4.2;  // Tamanho para desktop
                radius = 2.5;  // Mais larga
            }
            
            const thickness = 0.15;  // Espessura da parede
            
            // Material base com especular
            const baseMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                shininess: 100,
                specular: 0x111111
            });
            
            // Cilindro externo
            const outerCylinder = new THREE.CylinderGeometry(radius, radius, height, 32, 1, true);
            const outerMug = new THREE.Mesh(outerCylinder, baseMaterial.clone());
            outerMug.castShadow = true;
            mug.add(outerMug);
            
            // Material interno - CINZA
            const innerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x999999, // Cor cinza
                side: THREE.BackSide,
                shininess: 150,
                specular: 0xffffff
            });
            
            // Cilindro interno
            const innerCylinder = new THREE.CylinderGeometry(radius - thickness, radius - thickness, height, 32, 1, true);
            const innerMug = new THREE.Mesh(innerCylinder, innerMaterial);
            mug.add(innerMug);
            
            // Base da caneca
            const baseGeometry = new THREE.CylinderGeometry(radius, radius, thickness, 32);
            const base = new THREE.Mesh(baseGeometry, baseMaterial.clone());
            base.position.y = -height/2;
            base.castShadow = true;
            mug.add(base);
            
            // Base interna - CINZA
            const innerBaseGeometry = new THREE.CircleGeometry(radius - thickness, 32);
            const innerBase = new THREE.Mesh(innerBaseGeometry, new THREE.MeshPhongMaterial({
                color: 0x999999, // Cor cinza
                side: THREE.DoubleSide,
                shininess: 150,
                specular: 0xffffff
            }));
            innerBase.rotation.x = -Math.PI / 2;
            innerBase.position.y = -height/2 + thickness/2;
            mug.add(innerBase);
            
            // Alça com maior definição
            const handleCurve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(radius, height/4, 0),
                new THREE.Vector3(radius * 2, height/4, 0),
                new THREE.Vector3(radius * 2, -height/4, 0),
                new THREE.Vector3(radius, -height/4, 0)
            );
            
            const handleGeometry = new THREE.TubeGeometry(
                handleCurve,
                32,
                thickness * 1.8,
                8,
                false
            );
            
            const handle = new THREE.Mesh(handleGeometry, baseMaterial.clone());
            handle.castShadow = true;
            mug.add(handle);
            
            // Posição e rotação iniciais
            mug.rotation.x = 0;
            
            // Posicionar a caneca na mesa
            if (isMobile) {
                mug.position.y = 0.0;
            } else {
                mug.position.y = 0.0;
            }
            
            return mug;
        }
        
        // Configurar controles de interação
        function setupControls() {
            const frontImageInput = document.getElementById('frontImageInput');
            const backImageInput = document.getElementById('backImageInput');
            
            if (frontImageInput) {
                frontImageInput.addEventListener('change', (e) => handleImageUpload(e, 'front'));
            }
            
            if (backImageInput) {
                backImageInput.addEventListener('change', (e) => handleImageUpload(e, 'back'));
            }
            
            const canvases = document.querySelectorAll('canvas');
            canvases.forEach(canvas => {
                canvas.style.pointerEvents = 'none';
            });
        }
        
        // Função para lidar com upload de imagens
        function handleImageUpload(event, side) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    if (side === 'front') {
                        frontImageUrl = e.target.result;
                        applyImageToMug(frontImageUrl, 200, mugFront);
                    } else {
                        backImageUrl = e.target.result;
                        applyImageToMug(backImageUrl, 200, mugBack);
                    }
                };
                reader.readAsDataURL(file);
            }
        }
        
        // Aplicar imagem à caneca com maior nitidez
        function applyImageToMug(imageUrl, size, mug) {
            const texture = new THREE.TextureLoader().load(imageUrl, function(tex) {
                tex.anisotropy = 16;
                tex.minFilter = THREE.LinearFilter;
                tex.magFilter = THREE.LinearFilter;
                tex.generateMipmaps = false;
                
                const newMaterial = new THREE.MeshPhongMaterial({
                    map: tex,
                    shininess: 5,
                    specular: 0x222222
                });
                
                tex.wrapS = THREE.ClampToEdgeWrapping;
                tex.wrapT = THREE.ClampToEdgeWrapping;
                
                const outerCylinder = mug.children[0].geometry;
                
                if (!baseUVs) {
                    baseUVs = new Float32Array(outerCylinder.attributes.uv.array);
                }
                
                const uvs = outerCylinder.attributes.uv;
                uvs.array.set(baseUVs);
                
                const scale = size / 100;
                const isFrontMug = mug === mugFront;
                
                for (let i = 0; i < uvs.count; i++) {
                    let u = uvs.getX(i);
                    let v = uvs.getY(i);
                    
                    if (isFrontMug) {
                        if (u > 0.25 && u < 0.75) {
                            u = Math.max(0, Math.min(1, ((u - 0.25) * 2 * scale) + (0.5 - scale/2)));
                        } else {
                            u = 2;
                        }
                    } else {
                        if (u > 0.75 || u < 0.25) {
                            const adjustedU = u > 0.75 ? u - 0.75 : u + 0.25;
                            u = Math.max(0, Math.min(1, (adjustedU * 2 * scale) + (0.5 - scale/2)));
                        } else {
                            u = 2;
                        }
                    }
                    
                    uvs.setXY(i, u, v);
                }
                
 uvs.needsUpdate = true;
                mug.children[0].material = newMaterial;
                
                const renderer = isFrontMug ? rendererFront : rendererBack;
                renderer.setPixelRatio(window.devicePixelRatio * 1.5);
            });
        }
        
        // Redimensionamento da janela
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight * 0.45;
            
            // Em dispositivos móveis, usar uma proporção diferente
            if (width <= 768) {
                cameraFront.aspect = width / (window.innerHeight * 0.38);
                cameraBack.aspect = width / (window.innerHeight * 0.38);
            } else {
                cameraFront.aspect = width / height;
                cameraBack.aspect = width / height;
            }
            
            cameraFront.updateProjectionMatrix();
            cameraBack.updateProjectionMatrix();
            
            rendererFront.setSize(width, height);
            rendererBack.setSize(width, height);
        }
        
        // Loop de animação
        function animate() {
            requestAnimationFrame(animate);
            rendererFront.render(sceneFront, cameraFront);
            rendererBack.render(sceneBack, cameraBack);
        }

        // Classe para gerenciar preços
        class PriceManager {
            constructor() {
                this.prices = {
                    oneSide: 30.00,
                    twoSides: 35.00,
                    giftBox: 5.00
                };
                this.shippingPrice = 0;
                this.initializeListeners();
            }

            initializeListeners() {
                document.getElementById('oneSide').addEventListener('change', () => this.updatePrice());
                document.getElementById('twoSides').addEventListener('change', () => this.updatePrice());
                document.getElementById('giftBox').addEventListener('change', () => this.updatePrice());
                
                document.getElementById('cep').addEventListener('input', (e) => {
                    e.target.value = e.target.value.replace(/\D/g, '');
                });
            }

            getBasePrice() {
                return document.getElementById('twoSides').checked ? 
                    this.prices.twoSides : this.prices.oneSide;
            }

            updatePrice() {
                const basePrice = this.getBasePrice();
                const giftBoxPrice = document.getElementById('giftBox').checked ? 
                    this.prices.giftBox : 0;
                
                const breakdown = [];
                breakdown.push({
                    label: 'Caneca',
                    value: basePrice
                });

                if (giftBoxPrice > 0) {
                    breakdown.push({
                        label: 'Caixinha',
                        value: giftBoxPrice
                    });
                }

                if (this.shippingPrice > 0) {
                    breakdown.push({
                        label: 'Frete',
                        value: this.shippingPrice
                    });
                }

                const total = breakdown.reduce((sum, item) => sum + item.value, 0);

                document.getElementById('price-breakdown').innerHTML = breakdown
                    .map(item => `
                        <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                            <span>${item.label}</span>
                            <span>R$ ${item.value.toFixed(2)}</span>
                        </div>
                    `).join('');

                document.getElementById('total-price').textContent = 
                    `Total: R$ ${total.toFixed(2)}`;
            }

            setShippingPrice(price) {
                this.shippingPrice = price;
                this.updatePrice();
            }
        }

// Dentro da classe ShippingManager
class ShippingManager {
    constructor(priceManager) {
        this.priceManager = priceManager;
        this.correiosConfig = {
            cepOrigem: '59127450',
            peso: 0.5, // 500 gramas por caneca
            formato: 1, // Caixa/Pacote
            comprimento: 20,
            altura: 15,
            largura: 15,
            diametro: 0
        };
    }

    calculateShippingValue(distance) {
        // Valores fixos baseados na distância do CEP
        const baseValues = {
            PAC: {
                base: 20,
                perKm: 0.02,
                minDays: 5,
                maxDays: 10
            },
            SEDEX: {
                base: 35,
                perKm: 0.03,
                minDays: 2,
                maxDays: 5
            }
        };

        return {
            PAC: baseValues.PAC.base + (distance * baseValues.PAC.perKm),
            SEDEX: baseValues.SEDEX.base + (distance * baseValues.SEDEX.perKm)
        };
    }

            async calculateShipping(cep) {
                try {
                    const addressData = await this.getAddressFromCEP(cep);
                    document.getElementById('shipping-options').style.display = 'block';

                    // Cálculo SEDEX
                    const sedexPrice = await this.calculateCorreios(cep, this.correiosConfig.nCdServicoSEDEX);
                    // Cálculo PAC
                    const pacPrice = await this.calculateCorreios(cep, this.correiosConfig.nCdServicoPAC);

                    // Verificar se é em Natal para mostrar opção de motoboy
                    const motoboyOption = document.getElementById('motoboy-option');
                    if (addressData.localidade === 'Natal') {
                        motoboyOption.style.display = 'flex';
                        const taxa = this.getTaxaBairro(addressData.bairro);
                        motoboyOption.querySelector('.price').textContent = `R$ ${taxa.toFixed(2)}`;
                    } else {
                        motoboyOption.style.display = 'none';
                    }

                    this.saveAddress(addressData);
                } catch (error) {
                    console.error('Erro ao calcular frete:', error);
                    alert('Erro ao calcular o frete. Por favor, tente novamente.');
                }
            }

// Dentro da classe ShippingManager
async calculateCorreios(cep, servico) {
    try {
        // API Melhor Envio - simulação de valores
        const valorPAC = ((Math.random() * 10) + 20).toFixed(2);  // Entre R$20 e R$30
        const valorSEDEX = ((Math.random() * 15) + 35).toFixed(2); // Entre R$35 e R$50
        const prazoPAC = Math.floor(Math.random() * 5) + 5;  // Entre 5 e 10 dias
        const prazoSEDEX = Math.floor(Math.random() * 3) + 2;  // Entre 2 e 5 dias

        // Retornar valores com base no serviço solicitado
        if (servico === '04510') { // PAC
            return {
                valor: valorPAC,
                prazo: prazoPAC.toString()
            };
        } else { // SEDEX
            return {
                valor: valorSEDEX,
                prazo: prazoSEDEX.toString()
            };
        }
    } catch (error) {
        console.error('Erro detalhado:', error);
        throw new Error('Erro ao calcular frete dos Correios');
    }
}

// Atualizar a função calculateShipping
async calculateShipping(cep) {
    try {
        const addressData = await this.getAddressFromCEP(cep);
        const shippingResults = document.getElementById('shipping-options');
        shippingResults.style.display = 'block';

        // Calcular PAC
        const pacResult = await this.calculateCorreios(cep, '04510');
        const pacOption = document.querySelector('.shipping-option:nth-child(1)');
        pacOption.innerHTML = `
            <span>PAC (${pacResult.prazo} dias úteis)</span>
            <span class="price">R$ ${parseFloat(pacResult.valor).toFixed(2)}</span>
            <input type="radio" name="shipping" value="${pacResult.valor}" onchange="shippingManager.updateShippingPrice(this.value)">
        `;

        // Calcular SEDEX
        const sedexResult = await this.calculateCorreios(cep, '04014');
        const sedexOption = document.querySelector('.shipping-option:nth-child(2)');
        sedexOption.innerHTML = `
            <span>SEDEX (${sedexResult.prazo} dias úteis)</span>
            <span class="price">R$ ${parseFloat(sedexResult.valor).toFixed(2)}</span>
            <input type="radio" name="shipping" value="${sedexResult.valor}" onchange="shippingManager.updateShippingPrice(this.value)">
        `;

        // Verificar se é em Natal para mostrar opção de motoboy
        const motoboyOption = document.getElementById('motoboy-option');
        if (addressData.localidade === 'Natal') {
            const taxa = this.getTaxaBairro(addressData.bairro);
            motoboyOption.style.display = 'flex';
            motoboyOption.innerHTML = `
                <span>Motoboy (Mesmo dia)</span>
                <span class="price">R$ ${taxa.toFixed(2)}</span>
                <input type="radio" name="shipping" value="${taxa}" onchange="shippingManager.updateShippingPrice(this.value)">
            `;
        } else {
            motoboyOption.style.display = 'none';
        }

        this.saveAddress(addressData);

    } catch (error) {
        console.error('Erro ao calcular frete:', error);
        alert('Erro ao calcular o frete. Por favor, tente novamente.');
    }
}

// Adicionar método para atualizar preço do frete
updateShippingPrice(value) {
    this.priceManager.setShippingPrice(parseFloat(value));
}
            
            async getAddressFromCEP(cep) {
                const response = await fetch(`https://viacep.com.br/ws/${cep}/json/`);
                const data = await response.json();
                
                if (data.erro) {
                    throw new Error('CEP não encontrado');
                }
                
                return data;
            }

            getTaxaBairro(bairro) {
                const taxas = JSON.parse(localStorage.getItem('taxasBairros')) || [];
                const taxa = taxas.find(t => t.bairro.toLowerCase() === bairro.toLowerCase());
                return taxa ? taxa.valor : 15.00; // Taxa padrão de R$ 15,00
            }

            saveAddress(addressData) {
                localStorage.setItem('lastAddress', JSON.stringify(addressData));
            }
        }

        class GoogleIntegration {
    constructor() {
        this.driveFolder = '1Fa_2sCbaoRUSU4l7U_1SUENHtojUllHU';
        this.sheetId = '1UVt2nHY-z4hsguX2uIafLtX4m3A4toJkyClqA-jV4lI';
    }

    async uploadToGoogleDrive(imageFile, fileName) {
        try {
            const formData = new FormData();
            formData.append('file', imageFile);
            formData.append('folderId', this.driveFolder);
            formData.append('fileName', fileName);

            const response = await fetch('/api/upload-to-drive', {
                method: 'POST',
                body: formData
            });

            const data = await response.json();
            return data.fileUrl;
        } catch (error) {
            console.error('Erro ao fazer upload:', error);
            throw new Error('Erro ao fazer upload da imagem');
        }
    }

    async saveToGoogleSheets(orderData) {
        try {
            const response = await fetch('/api/save-to-sheets', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sheetId: this.sheetId,
                    data: orderData
                })
            });

            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Erro ao salvar na planilha:', error);
            throw new Error('Erro ao salvar pedido');
        }
    }
}

        // Inicializar gerenciadores
        const priceManager = new PriceManager();
        const shippingManager = new ShippingManager(priceManager);

        // Função global para calcular frete
        function calcularFrete() {
            const cep = document.getElementById('cep').value.replace(/\D/g, '');
            
            if (cep.length !== 8) {
                alert('Por favor, digite um CEP válido');
                return;
            }

            shippingManager.calculateShipping(cep);
        }

        // Carregar último endereço usado
        window.addEventListener('load', () => {
            const lastAddress = localStorage.getItem('lastAddress');
            if (lastAddress) {
                const address = JSON.parse(lastAddress);
                document.getElementById('cep').value = address.cep.replace(/\D/g, '');
            }
        });
    </script>
</body>
</html>
